# -*- coding: utf-8 -*-
"""RNN2.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19hMVGG_FOEbwfZs3-WF_26WDNQE2tuGg
"""

import os
import glob
import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
from sklearn.preprocessing import StandardScaler
from tqdm import tqdm

# ============ CONFIGURATION ============
TEAM_NAME_MAP = {
    'ATL': 'Atlanta Hawks', 'BOS': 'Boston Celtics', 'BRK': 'Brooklyn Nets',
    'BKN': 'Brooklyn Nets', 'CHA': 'Charlotte Hornets', 'CHI': 'Chicago Bulls',
    'CLE': 'Cleveland Cavaliers', 'DAL': 'Dallas Mavericks', 'DEN': 'Denver Nuggets',
    'DET': 'Detroit Pistons', 'GSW': 'Golden State Warriors', 'HOU': 'Houston Rockets',
    'IND': 'Indiana Pacers', 'LAC': 'Los Angeles Clippers', 'LAL': 'Los Angeles Lakers',
    'MEM': 'Memphis Grizzlies', 'MIA': 'Miami Heat', 'MIL': 'Milwaukee Bucks',
    'MIN': 'Minnesota Timberwolves', 'NOP': 'New Orleans Pelicans', 'NYK': 'New York Knicks',
    'OKC': 'Oklahoma City Thunder', 'ORL': 'Orlando Magic', 'PHI': 'Philadelphia 76ers',
    'PHX': 'Phoenix Suns', 'POR': 'Portland Trail Blazers', 'SAC': 'Sacramento Kings',
    'SAS': 'San Antonio Spurs', 'TOR': 'Toronto Raptors', 'UTA': 'Utah Jazz',
    'WAS': 'Washington Wizards',
    # full name mappings
    'Detroit Pistons': 'Detroit Pistons', 'Indiana Pacers': 'Indiana Pacers',
    'San Antonio Spurs': 'San Antonio Spurs', 'New Jersey Nets': 'New Jersey Nets',
    'Dallas Mavericks': 'Dallas Mavericks'
}

# ============ DATA LOADING ============
def load_player_stats(base_path):
    ...  # unchanged from existing file

def load_playoff_stats(base_path):
    ...  # unchanged from existing file

# ============ PREPROCESSING ============
def preprocess_data(player_df, playoff_df):
    ...  # unchanged from existing file

# ============ DATASET CLASS ============
class NBADataset(Dataset):
    def __init__(self, player_arrays, team_features, targets, original_indices=None):
        self.player_data = torch.FloatTensor(player_arrays)
        self.team_data = torch.FloatTensor(team_features)
        self.targets = torch.FloatTensor(targets)
        self.original_indices = original_indices if original_indices is not None else np.arange(len(targets))

    def __len__(self):
        return len(self.targets)

    def __getitem__(self, idx):
        return {
            'player_stats': self.player_data[idx],  # [players, features]
            'team_features': self.team_data[idx],
            'target': self.targets[idx],
            'original_idx': self.original_indices[idx]
        }

# ============ RNN-BASED NEURAL NETWORK ============
class HybridNBAModel(nn.Module):
    def __init__(self, n_players, n_player_features=12, n_team_features=16):
        super().__init__()
        # player pathway (RNN)
        self.player_rnn = nn.LSTM(
            input_size=n_player_features,
            hidden_size=64,
            num_layers=1,
            batch_first=True
        )
        self.player_fc = nn.Sequential(
            nn.Linear(64, 128),
            nn.ReLU(),
            nn.Dropout(0.3)
        )
        # team pathway (fully connected)
        self.team_net = nn.Sequential(
            nn.Linear(n_team_features, 128),
            nn.BatchNorm1d(128),
            nn.ReLU(),
            nn.Dropout(0.3)
        )
        # combined network
        self.combined = nn.Sequential(
            nn.Linear(256, 128),  # 128 from RNN + 128 from team
            nn.BatchNorm1d(128),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(128, 1)
        )

    def forward(self, player_stats, team_features):
        # player_stats: [batch, n_players, n_features]
        rnn_out, (h_n, c_n) = self.player_rnn(player_stats)
        # take the last hidden state
        player_out = self.player_fc(h_n[-1])  # [batch, 64] -> [batch, 128]
        team_out = self.team_net(team_features)
        combined = torch.cat([player_out, team_out], dim=1)
        return self.combined(combined).squeeze()

# ============ TRAINING & EVALUATION ============
class NBASubset(torch.utils.data.Subset):
    def __getitem__(self, idx):
        item = self.dataset[self.indices[idx]]
        return {
            'player_stats': item['player_stats'],
            'team_features': item['team_features'],
            'target': item['target'],
            'original_idx': self.indices[idx]
        }

def train_and_evaluate(base_path, output_dir="Results"):
    # load and preprocess data
    player_df = load_player_stats(base_path)
    playoff_df = load_playoff_stats(base_path)
    X_player, X_team, y, meta = preprocess_data(player_df, playoff_df)

    # full dataset
    full_dataset = NBADataset(X_player, X_team, y)
    seasons = sorted(meta['Season'].unique())
    all_results = []

    for season in seasons:
        ...  # unchanged from existing file

    ...  # saving results, unchanged

if __name__ == "__main__":
    results = train_and_evaluate("Preprocessing/Preprocessed Data")
    print(results.head(20))